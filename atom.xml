<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chuzihang714.github.io</id>
    <title>chuzihang714&apos;s blog</title>
    <updated>2021-04-07T10:02:06.335Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chuzihang714.github.io"/>
    <link rel="self" href="https://chuzihang714.github.io/atom.xml"/>
    <subtitle>At its summit goodbye.</subtitle>
    <logo>https://chuzihang714.github.io/images/avatar.png</logo>
    <icon>https://chuzihang714.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, chuzihang714&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【杂】]]></title>
        <id>https://chuzihang714.github.io/post/za/</id>
        <link href="https://chuzihang714.github.io/post/za/">
        </link>
        <updated>2021-04-04T13:20:17.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】3.31/4.2膜你赛总结]]></title>
        <id>https://chuzihang714.github.io/post/oi-33142-mo-ni-sai-zong-jie/</id>
        <link href="https://chuzihang714.github.io/post/oi-33142-mo-ni-sai-zong-jie/">
        </link>
        <updated>2021-04-01T23:54:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="331"><strong>3.31</strong></h2>
<h3 id="t1"><strong>T1</strong></h3>
<p>导弹拦截魔改...简单的 <big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></big> 可我竟然调了1hour...</p>
<h4 id="code"><strong>Code</strong></h4>
<p>简单题不放了</p>
<h3 id="t2"><strong>T2</strong></h3>
<p>每次找中间的 <big><code>l</code></big> 然后往两边搜，若不能匹配再减一下就好...</p>
<h4 id="code-2"><strong>Code</strong></h4>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

inline ll read()
{
								ll a=0,f=1;
								char ch=getchar();
								for(; !isdigit(ch); ch=getchar())
																if(ch=='-') f=-1;
								for(; isdigit(ch); ch=getchar())
																a=(a&lt;&lt;3)+(a&lt;&lt;1)+ch-'0';
								return a*f;
}

const ll mod=1e9+7;
const int N=1e6+5;
long long num1,num2,n,num,ans;

inline ll qpow(ll a,ll n)
{
								ll ans=1;
								for(; n; n&gt;&gt;=1)
								{
																if(n&amp;1) ans=(ans*a)%mod;
																a=(a*a)%mod;
								}
								return ans;
}

signed main()
{
								freopen(&quot;jiangge.in&quot;,&quot;r&quot;,stdin);
								freopen(&quot;jiangge.out&quot;,&quot;w&quot;,stdout);
								n=read();
								for(int i=1; i&lt;=n; i++)
								{
																char ch=getchar();
																if(ch=='b') ans =( ans+num2)%mod;
																else if(ch=='l') num2=(num2+num1)%mod;
																else if(ch=='a') num1=(num1+qpow(3,num))%mod;
																else if(ch=='?')
																{
																								ans =(ans*3%mod+num2)%mod;
																								num2=(num2*3%mod+num1)%mod;
																								num1=(num1*3%mod+qpow(3,num))%mod;
																								num++; num%=mod;
																}
//		printf(&quot;%lld---&gt;%lld---&gt;%lld\n&quot;,num1,num2,ans);
//		if(num1&lt;0)break;
								}
								printf(&quot;%lld\n&quot;,(ans+mod)%mod);
								return 0;
}
/*
   600849148
 */
</code></pre>
<h3 id="t4"><strong>T4</strong></h3>
<p>原本以为这题很难...实则有一种很水的解法可以卡过去（原题可过，比赛题时间复杂度是wa的）<br>
就是先将序列变成差值序列，然后找一个序列，枚举左端点，取一个匹配到的最短的序列再和答案取个max即可。</p>
<h4 id="code-3"><strong>Code</strong></h4>
<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define int long long
using namespace std;
const int N=1e3+10;
int n,m[N],a[N][N],ans,i,j,l,r,maxx,p,rr;
signed main()
{
        cin &gt;&gt; n;
        for(i=1; i&lt;=n; i++)
        {
                cin &gt;&gt; m[i];
                for(j=1; j&lt;=m[i]; j++)
                        scanf(&quot;%lld&quot;,&amp;a[i][j]);
                m[i]--;
                if(m[i]==0) {puts(&quot;1&quot;); return 0;}
                for(j=1; j&lt;=m[i]; j++)
                        a[i][j]=a[i][j+1]-a[i][j];
        }
        for(l=1; l&lt;=m[1]; l++)
        {
                r=m[1];
                for(i=2; i&lt;=n; i++)
                {
                        maxx=0;
                        for(j=1; j&lt;=m[i]; j++)
                        {
                                if(a[i][j]==a[1][l])
                                {
                                        p=j,rr=l;
                                        while(a[i][p]==a[1][rr] &amp;&amp; p&lt;=m[i] &amp;&amp; rr&lt;=r)
                                                rr++,p++;
                                        maxx=max(maxx,rr-1);
                                }
                        }
                        r=min(r,maxx);
                }
                ans=max(ans,r-l+1);
        }
        cout&lt;&lt;ans+1;
}

</code></pre>
<h2 id="42"><strong>4.2</strong></h2>
<h3 id="t4-2"><strong>T4</strong></h3>
<h4 id="idea"><strong>Idea</strong></h4>
<p>不难看出，这是一道 <big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> </big>题，但是发现求没被激活的集合数有点难？怎么办？我们可以求出被激活的集合数（因为其是一一对应的）。又因为每个机器人被激活后会激活后面的一系列机器人，那么我们就只需要将这个机器人和它所能激活的一系列机器人缩到一起就可以了。<br>
我们先定义  <big> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">to[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> </big>为激活第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个机器人后至 <big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">to[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></big> 个都会被激活。</p>
<p><big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></big>方程也很好推：<br>
<big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></big> 表示<strong>不激活</strong>机器人 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 时 机器人 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 后的集合数。<br>
<big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></big> 表示<strong>激活</strong>机器人 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是 机器人 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 后的集合数。<br>
那么<br>
<big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,0]=f[i+1,0]+f[i+1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></big><br>
<big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>f</mi><mo>[</mo><mi>t</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mi>t</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[i,1]=f[to[i],0]+f[to[i],1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></big></p>
<p>那么接下来的问题就是如何求 <big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>o</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">to[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></big> 了，这也很好办，二分一下然后用线段树查找一下最值即可。（别问为什么用线段树，问就是这几星期学图论锻炼一下线段树能力）</p>
<p>最后答案就是 <big><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo>]</mo><mo>+</mo><mi>f</mi><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f[1,0]+f[1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></big></p>
<h4 id="code-4"><strong>Code</strong></h4>
<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define int long long
using namespace std;
const int N = 200001;
const int mod = 998244353;
int n,f[N][2],maxx[N],to[N];
struct stu
{
        int qi,la;
};
bool cmp(stu x, stu y)
{
        return x.qi&lt;y.qi;
}
stu a[N];

int ls(int val)
{
        return val&lt;&lt;1;
}
int rs(int val)
{
        return val&lt;&lt;1|1;
}

void pushup(int p)
{
        maxx[p]=max(maxx[ls(p)],maxx[rs(p)]);
}
void updata(int l, int r, int p, int val, int k)
{
        if(l==r) {maxx[p] = k; return;}
        int mid=(l+r)/2;
        if (val&lt;=mid) updata(l, mid, ls(p), val, k);
        else updata(mid + 1, r, rs(p), val, k);
        pushup(p);
}
int maxv(int l, int r, int p, int ll, int rr)
{
        if (ll &gt; rr) return 0;
        if (l &gt;= ll &amp;&amp; r &lt;= rr) return maxx[p];
        int mid = l + r &gt;&gt; 1, res = 0;
        if (ll &lt;= mid) res = maxv(l, mid, ls(p), ll, rr);
        if (rr &gt; mid) res = max(res, maxv(mid + 1, r, rs(p), ll, rr));
        return res;
}
signed main()
{
        cin &gt;&gt; n;
        for (int i=1; i&lt;=n; i++) cin &gt;&gt; a[i].qi &gt;&gt; a[i].la;//qi 起点 la到哪
        sort(a+1,a+n+1,cmp);//先按起点从小到大排序

        for (int i=n; i; --i)
        {
                int l = i, r = n, mid, sum = 0;

                while (l&lt;=r)
                {
                        int mid=(l+r)/2;
                        if (a[mid].qi&lt;a[i].qi+a[i].la) l=mid+1,sum=mid;
                        else r=mid-1;
                }
                to[i]=max(r+1,maxv(1,n,1,i+1,sum));
                updata(1,n,1,i,to[i]);
        }//二分求to[i]

        f[n+1][0]=1;
        for (int i=n; i&gt;=1; i--)
        {
                f[i][0]=(f[i+1][1]+f[i+1][0]) % mod;
                f[i][1]=(f[to[i]][0]+f[to[i]][1]) % mod;
        }//dp
        cout &lt;&lt; (f[1][0]+f[1][1]) % mod;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】树上问题笔记]]></title>
        <id>https://chuzihang714.github.io/post/shu-shang-wen-ti-bi-ji/</id>
        <link href="https://chuzihang714.github.io/post/shu-shang-wen-ti-bi-ji/">
        </link>
        <updated>2021-03-30T02:46:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义"><strong>定义：</strong></h2>
<p>自行 <a href="http://oi-wiki.com/graph/tree-basic/"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>OI-Wiki</mtext></mrow><annotation encoding="application/x-tex">\text{OI-Wiki}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord">OI-Wiki</span></span></span></span></span></a> 。</p>
<h2 id="树的直径"><strong>树的直径</strong></h2>
<p>有两种解法。</p>
<h3 id="sol1"><strong>sol1</strong></h3>
<p>跑两遍大法师，第一遍找最远的结点，这个结点就是直径的一端，第二遍找以 <code>第一遍找出的点</code> 为根节点的最远的节点，这个点就是直径的第二端。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<h4 id="证明"><strong>证明：</strong></h4>
<p>再次自行 <strong>OI-Wiki</strong></p>
<h4 id="code"><strong>Code</strong></h4>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const int N = 1e7 + 7;
int id, maxn, n, deep[N];
struct edge 
{
        int to, next;
} e[N];
int cnt, he[N];

void add(int u, int v) 
{
        e[++cnt].next = he[u];
        e[cnt].to = v;
        he[u] = cnt;
}

void dfs(int u, int fa) 
{

        if(deep[u] &gt; maxn)
                id = u, maxn = deep[u];

        for(int i = he[u]; i; i = e[i].next) 
        {
                int v = e[i].to;
                if(v == fa)
                        continue;
                deep[v] = deep[u] + 1;
                dfs(v, u);
        } // 我要 ak ioi 的
}

int main()
{
        cin &gt;&gt; n;
        for(int i = 1; i &lt;= n - 1; i++)
        {
                int u,v;
                cin &gt;&gt; u &gt;&gt; v;
                add(u, v), add(v, u);
        }

        dfs(1, 0);

        memset(deep, 0, sizeof(deep));
        maxn = 0;

        dfs(id, 0);

        printf(&quot;%d&quot;, maxn);
        return 0;
}

</code></pre>
<h3 id="sol2"><strong>sol2</strong></h3>
<p>用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 写，分别记录每个点向下所能延伸的最大值与次大值，直径就是两者的加和。</p>
<h4 id="code-2"><strong>Code</strong></h4>
<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int x,y,n,i,ans,d1[100001],d2[100001],t;
vector&lt;int&gt; E[100001];

void dfs(int now, int fath)
{
        d1[now]=d2[now]=0;
        for(int i = 0; i &lt; E[now].size(); ++i)
        {
                int v=E[now][i];
                if (fath==v) continue;
                dfs(v,now);
                t=d1[v]+1;
                if (t&gt;d1[now]) d2[now]=d1[now],d1[now]=t;
                else if (t&gt;d2[now]) d2[now]=t;
        }
        ans=max(ans,d1[now]+d2[now]);
}

int main()
{
        cin &gt;&gt; n;
        for (i=1; i&lt;n; i++)
        {
                int u,v;
                cin &gt;&gt; u &gt;&gt; v;
                E[u].push_back(v);
                E[v].push_back(u);
        }
        dfs(1,0);
        cout &lt;&lt; ans;
        return 0;
}
</code></pre>
<h2 id="lca最近公共祖先"><strong>LCA最近公共祖先</strong></h2>
<p>可以用 <code>tarjan</code> 写（显然我只看了这一个...）<br>
做法：用临接链表存下每条边和询问的信息，然后跑一遍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span> ，最后对于询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>c</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">lca</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span></span></span></span> ，答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>d</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mn>2</mn><mo>∗</mo><mi>d</mi><mi>d</mi><mo>[</mo><mi>L</mi><mi>C</mi><mi>A</mi><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dd[i]+dd[j]-2*dd[LCA(i,j)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span> ，这里 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dd[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 点到根节点的距离。</p>
<h3 id="code-3"><strong>Code</strong></h3>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100010;
int x,y,k,question[N],edge[N],tot,tot1,fa[N],dd[N],lca[N],que1[N],que2[N];//d[i]表示该节点到根节点的距离，fa是父亲节点
bool ff[N];
struct EDGE
{
        int to,v,next;
};
EDGE a[N];
struct QUES
{
        int to,nu,next;
};
QUES b[N];

void add_edge(int x,int y,int value)
{
        a[++tot].to=y;//这条边到哪个点
        a[tot].v=value;//这条边的长度
        a[tot].next=edge[x];//与这条边有相同初始点的上一条边编号 
        edge[x]=tot;//更新
}
void add_question(int x,int y,int number)
{
        b[++tot1].to=y;//询问点编号
        b[tot1].nu=number;
        b[tot1].next=question[x];
        question[x]=tot1;
}

int get (int x)
{
        if (fa[x]==x) return x;
        return fa[x]=get(fa[x]);
}//并查集

void tarjan(int x)
{
        fa[x]=x;//将父节点指向自己
        ff[x]=true;//标记该点已经走过
        for(int i=question[x]; i; i=b[i].next)
        {
                int now=b[i].to;
                if(ff[now])
                        lca[b[i].nu]=get(now);//更新lca
        }
        for(int i=edge[x]; i; i=a[i].next)
        {
                int now=a[i].to;
                if(!ff[now])
                {
                        dd[now]=dd[x]+a[i].v;//更新dd
                        tarjan(now);
                        fa[now]=x;//更新父节点
                }
        }
}
int main()
{
        int tt;
        cin &gt;&gt; tt;
        while (tt--)
        {
                int n,m;
                cin &gt;&gt; n &gt;&gt; m;
                memset(ff,false,sizeof(ff));
                memset(edge,0,sizeof(edge));
                memset(question,0,sizeof(question));
                memset(a,0,sizeof(a));
                memset(b,0,sizeof(b));
                memset(dd,0,sizeof(dd));
                memset(fa,0,sizeof(fa));
                for (int i=1; i&lt;=n; i++) fa[i]=i;
                tot=0; tot1=0;//预处理
                for(int i=1; i&lt;=n-1; i++)
                {
                        int aa,bb,cc;
                        scanf(&quot;%d%d%d&quot;,&amp;aa,&amp;bb,&amp;cc);
                        add_edge(aa,bb,cc);
                        add_edge(bb,aa,cc);
                }//建树
                for(int i=1; i&lt;=m; i++)
                {
                        int aa,bb;
                        scanf(&quot;%d%d&quot;,&amp;aa,&amp;bb);
                        add_question(aa,bb,i);
                        add_question(bb,aa,i);//安全一点存两次
                        que1[i]=aa,que2[i]=bb;
                }
                tarjan(1);
                for (int i=1; i&lt;=m; i++)
                        printf(&quot;%d\n&quot;,dd[que1[i]]+dd[que2[i]]-2*dd[lca[i]]);
        }
}
</code></pre>
<h2 id="树的重心"><strong>树的重心</strong></h2>
<h3 id="定义-2"><strong>定义：</strong></h3>
<p>对于一棵树n个节点的无根树，找到一个点，将无根树变为以该点为根的有根树时，最大子树的结点数最小。换句话说，删除这个 1 点后最大连通块（一定是树）的结点数最小。</p>
<h3 id="sol"><strong>Sol</strong></h3>
<p>用大法师计算每个子树大小，利用<code>总点数 - 当前子树</code>的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。</p>
<h3 id="code-4"><strong>Code</strong></h3>
<pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#define LL long long
#define inf 2147483640
#define Pi acos(-1.0)
#define free(a) freopen(a &quot;.in&quot;,&quot;r&quot;,stdin),freopen(a &quot;.out&quot;,&quot;w&quot;,stdout);
using namespace std;

const int maxn=20010;
struct edge {int to,next;} e[maxn&lt;&lt;2];

int head[maxn],vis[maxn],son[maxn],cnt,size,ans,n;

void insert(int u,int v) {
        e[++cnt].to=v; e[cnt].next=head[u]; head[u]=cnt;
        e[++cnt].to=u; e[cnt].next=head[v]; head[v]=cnt;
}
void dfs(int x) {
        vis[x]=1,son[x]=0;
        int tmp=0;
        for (int i=head[x]; i; i=e[i].next) if (!vis[e[i].to]) {
                        dfs(e[i].to);
                        son[x]+=son[e[i].to]+1;
                        tmp=max(tmp,son[e[i].to]+1);
                }
        tmp=max(tmp,n-son[x]-1);
        if (tmp&lt;size || (tmp==size &amp;&amp; x&lt;ans)) size=tmp,ans=x;
}
int main() {
        int T; scanf(&quot;%d&quot;,&amp;T);
        while (T--) {
                scanf(&quot;%d&quot;,&amp;n);
                memset(vis,0,sizeof(vis)); memset(head,0,sizeof(head));
                cnt=ans=0; size=inf;
                for (int i=1; i&lt;n; i++) {
                        int u,v;
                        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
                        insert(u,v);
                }
                dfs(1);
                printf(&quot;%d %d\n&quot;,ans,size);
        }
        return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】膜你赛3.26小结]]></title>
        <id>https://chuzihang714.github.io/post/oi/</id>
        <link href="https://chuzihang714.github.io/post/oi/">
        </link>
        <updated>2021-03-26T10:06:59.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="野花终于良心地出了套模拟赛了啊普及"><strong>野花终于良心地出了套模拟赛了啊...(普及)</strong></h3>
<h3 id="结果这个文件提交我真的赣了啊"><strong>结果这个文件提交我真的赣了啊...</strong></h3>
<h3 id="t1t2"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T1/T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span></strong></h3>
<p>这两题都很简单，找出其中的规律就行。<br>
要注意的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span> 在没有一张卡牌是 奇/偶 的情况下是无解的，特判一下，比赛数据太水竟然给过了，但CF上过不了。</p>
<h3 id="t3"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">T3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">3</span></span></span></span></strong></h3>
<p>暴力就能过，如何判断形状相同这点有点难想，其实可以把形状转化成数字来做。（定一点 其他各点到这个点的距离和就可视为这个图案）</p>
<h3 id="t4"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">T4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">4</span></span></span></span></strong></h3>
<p>也是很水的一题，考场上以为是正解，结果只考虑了最后一个女生第一步需等待的情况... 再开一个数组记录每个连通块中最后的一个女生需等待多久并每次更新一下即可...</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="野花终于良心地出了套模拟赛了啊普及"><strong>野花终于良心地出了套模拟赛了啊...(普及)</strong></h3>
<h3 id="结果这个文件提交我真的赣了啊"><strong>结果这个文件提交我真的赣了啊...</strong></h3>
<h3 id="t1t2"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>1</mn><mi mathvariant="normal">/</mi><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T1/T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span></strong></h3>
<p>这两题都很简单，找出其中的规律就行。<br>
要注意的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">T2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">2</span></span></span></span> 在没有一张卡牌是 奇/偶 的情况下是无解的，特判一下，比赛数据太水竟然给过了，但CF上过不了。</p>
<h3 id="t3"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">T3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">3</span></span></span></span></strong></h3>
<p>暴力就能过，如何判断形状相同这点有点难想，其实可以把形状转化成数字来做。（定一点 其他各点到这个点的距离和就可视为这个图案）</p>
<h3 id="t4"><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">T4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">4</span></span></span></span></strong></h3>
<p>也是很水的一题，考场上以为是正解，结果只考虑了最后一个女生第一步需等待的情况... 再开一个数组记录每个连通块中最后的一个女生需等待多久并每次更新一下即可...</p>
<!-- more -->
<p>sxyz2021求真班成员提醒您：<br>
<strong>题目千万道，文件要交好；</strong><br>
<strong>不检查文件，爆零两行泪。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【整活】“chuzihang714” 与 “nottttttthy的读法”]]></title>
        <id>https://chuzihang714.github.io/post/zheng-huo-chuzihang714-yu-nottttttthy-de-du-fa/</id>
        <link href="https://chuzihang714.github.io/post/zheng-huo-chuzihang714-yu-nottttttthy-de-du-fa/">
        </link>
        <updated>2021-03-24T12:06:50.000Z</updated>
        <content type="html"><![CDATA[<p><code>chuzihang</code> 中文是楚子航，是小说龙族中我喜欢的一个角色。<br>
而<code>714</code> 是一个有特殊意义的数字.</p>
<p><code>nottttttthy</code> 的正确发音应该是 <code>[ˈnɒθiː]</code>   没有别的特殊含义...只是因为原本名字是nothing2333 ...</p>
<p>其他整活：</p>
<ol>
<li><a href="https://caixy06.blog.luogu.org/caixy06-di-du-fa"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#ffE1F2"><mtext>鱼的</mtext></mstyle></mrow><annotation encoding="application/x-tex">\text{\color{#ffE1F2}鱼的}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback" style="color:#ffE1F2;">鱼的</span></span></span></span></span></a></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">~\\
~\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span></span></span></span></p>
<ol start="2">
<li><a href="https://www.luogu.com.cn/blog/Acfboy/acfboy-di-du-fa"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#5ac5ac"><mtext>Acfboy</mtext></mstyle></mrow><annotation encoding="application/x-tex">\text{\color{#5ac5ac}Acfboy}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord" style="color:#5ac5ac;">Acfboy</span></span></span></span></span></a></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">~\\
~\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span></span></span></span></p>
<ol start="3">
<li><a href="https://www.luogu.com.cn/blog/ZLY/life-di-du-fa-tai-wu-post"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#1111cc"><mtext>_Life_</mtext></mstyle></mrow><annotation encoding="application/x-tex">\text{\color{#1111cc}\_Life\_}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord" style="color:#1111cc;">_Life_</span></span></span></span></span></a></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">~\\
~\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span></span></span></span></p>
<ol start="4">
<li><a href="https://yifanlg.blog.luogu.org/post-long-qian-yue-shi-wu-di-du-fa"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#dd11cc"><mtext>龙虾十三香</mtext></mstyle></mrow><annotation encoding="application/x-tex">\text{\color{#dd11cc}龙虾十三香}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback" style="color:#dd11cc;">龙虾十三香</span></span></span></span></span></a></li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext> </mtext><mspace linebreak="newline"></mspace><mtext> </mtext><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">~\\
~\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mspace nobreak"> </span></span><span class="mspace newline"></span></span></span></span></p>
<ol start="5">
<li><a href="https://www.luogu.com.cn/blog/CatHome/ninelifecat-di-du-fa"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathcolor="#ddccbb"><mtext>Ninelife_Cat</mtext></mstyle></mrow><annotation encoding="application/x-tex">\text{\color{#ddccbb}Ninelife\_Cat}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord text"><span class="mord" style="color:#ddccbb;">Ninelife_Cat</span></span></span></span></span></a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】线段树笔记]]></title>
        <id>https://chuzihang714.github.io/post/oi-xian-duan-shu-bi-ji/</id>
        <link href="https://chuzihang714.github.io/post/oi-xian-duan-shu-bi-ji/">
        </link>
        <updated>2021-03-23T12:27:39.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="用法">用法</h2>
<p>是什么，干什么用的就不写了，每篇都有...都看烦了...</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="用法">用法</h2>
<p>是什么，干什么用的就不写了，每篇都有...都看烦了...</p>
<!-- more -->
<h2 id="过程">过程</h2>
<p>主要过程就是 <strong>建树 -&gt; 更新 -&gt; 查询输出</strong></p>
<!-- more -->
<h2 id="板子code">板子code</h2>
<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define int long long
using namespace std;
int n,m,a[100001],tree[1000001],lazy[1000001],mid,b,c,d,e,f,a1,i;

void push_up(int p)
{
        tree[p]=tree[p*2]+tree[p*2+1];
}

void swa(int p, int l,int r, int k)
{
        lazy[p]+=k;
        tree[p]=tree[p]+k*(r-l+1);
}

void push_down(int p, int l, int r)
{
        mid=(l+r) / 2;
        swa(p*2,l,mid,lazy[p]);
        swa(p*2+1,mid+1,r,lazy[p]);
        lazy[p]=0;
}

void build(int p, int l, int r)
{
        lazy[p]=0;
        if (l==r) {tree[p]=a[l]; return;}
        int mid=(l+r)/2;
        build(p*2,l,mid);
        build(p*2+1,mid+1,r);
        tree[p]=tree[p*2+1]+tree[p*2];
}

void update(int ll,int rr,int l,int r,int p,int k)
{
        if(ll&lt;=l&amp;&amp;r&lt;=rr)
        {
                tree[p]+=k*(r-l+1);
                lazy[p]+=k;
                return;
        }

        push_down(p,l,r);
        int mid=(l+r) / 2;
        if(ll&lt;=mid) update(ll,rr,l,mid,p*2,k);
        if(rr&gt;mid) update(ll,rr,mid+1,r,p*2+1,k);
        push_up(p);
}

int query(int xx,int yy,int l,int r,int p)
{
        int sum=0;
        if(xx&lt;=l&amp;&amp;r&lt;=yy) return tree[p];
        int mid=(l+r)&gt;&gt;1;
        push_down(p,l,r);
        if(xx&lt;=mid) sum+=query(xx,yy,l,mid,p*2);
        if(yy&gt;mid) sum+=query(xx,yy,mid+1,r,p*2+1);
        return sum;
}
signed main()
{
        cin &gt;&gt; n &gt;&gt; m;
        for (i=1; i&lt;=n; i++) cin &gt;&gt; a[i];
        build(1,1,n);
        while (m--)
        {
                cin &gt;&gt; a1;
                if (a1==1)
                {
                        cin &gt;&gt; b &gt;&gt; c &gt;&gt; d;
                        update(b,c,1,n,1,d);
                }
                else
                {
                        cin &gt;&gt; e &gt;&gt; f;
                        cout &lt;&lt; query(e,f,1,n,1) &lt;&lt; endl;
                }
        }
}

</code></pre>
<!-- more -->
<p>有点难懂的是懒标记，多看一会儿能理解。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【影片】辛德勒的名单]]></title>
        <id>https://chuzihang714.github.io/post/ying-pian-xin-de-le-de-ming-dan/</id>
        <link href="https://chuzihang714.github.io/post/ying-pian-xin-de-le-de-ming-dan/">
        </link>
        <updated>2021-03-20T03:33:02.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="写在前面">写在前面：</h2>
<p>本篇博客有剧透，介意者勿看。（顺便补充些历史故事...</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面：</h2>
<p>本篇博客有剧透，介意者勿看。（顺便补充些历史故事...</p>
<!-- more -->
<p>影片改编自一个发生在二战期间的历史故事。开幕时，一只（有颜色的）蜡烛出现在眼前，随后所有事物都变为黑白。<br>
<strong>首先，辛德勒是一个德国纳粹</strong>。</p>
<h2 id="-more-"><!-- more --></h2>
<h2 id="1">1</h2>
<p>在此先将影片分成 两部分 ，在第一部分中，辛德勒无疑只是个商人，他买下那些犹太人为自己工作纯属是因为那时的犹太人身价低廉。在这期间他结识了他的秘书 · 伊萨克·斯特恩 · 。他们将搪瓷厂越办越大，实发了一笔“战争财”，辛德勒在此时已成了一个成功的商人并拥有丰厚的资金，他本人也过着十分奢侈的生活。<br>
注：到了1944年的高峰时期，工厂一共雇佣了约1750名工人，其中约1000是犹太人。<br>
注：当影片的第一部分结束时，若没看过剧透，大多数观众（其实就是我）都无法理解其内容。</p>
<h2 id="-more--2"><!-- more --></h2>
<h2 id="2">2</h2>
<p>而在影片的第二部分，他开始对犹太人表示同情，并开始不顾成本地为工人提供保护，每当辛德勒的犹太人面对驱逐的威胁时，他就会宣布豁免他们。他亲眼目睹了德军对犹太人区惨绝人寰的清理并深感震惊。1941年秋，纳粹开始将犹太人区居住的犹太人转移，其中大部分被送到贝尔赛克灭绝营杀害。据辛德勒犹太人索尔·乌尔巴克所说，辛德勒从那时起“改变了对纳粹的看法，决心尽可能多救出一些犹太人。“他用他的军事关系，把奉承、贿赂及外交手腕相结合，保证他的工人不会被处决且尽可能 ”自由“。</p>
<!-- more -->
<p>1944年7月，由于苏联红军的节节逼近，亲卫队开始关闭最东面的集中营，把余下的囚犯向西转移到奥斯威辛和格罗斯-罗森集中营。辛德勒通过贿赂和劝说，最终让哥特及远在柏林的官员同意他把工厂和工人转移到苏德台地区一个名叫布瑞恩利兹的小乡村，从而免除了工人被送入毒气室处死。他列出了一张名单，名单上是他要带走的工人的名字。<br>
”这份名单…就是生命。“</p>
<!-- more -->
<p>但在列车运输工人时，又出了意外，男工人按约到达了瑞恩利兹，而女工人却仍被运往了奥斯维辛。后来他通过向官员贿赂 钻石 等稀有物品才将女工人们带出。</p>
<!-- more -->
<p>随着苏联红军的逼近，辛德勒为避免工人被亲卫队所杀而继续向军官行贿。最后，苏联胜利了，他与工人们一起在午夜聆听德国投降的消息，随后工人们为报答他的救命之恩，为他写了一份说明以表示他曾搭救过犹太人以防他被苏联红军抓住。他们还送给他一枚金戒指，上面刻有“救一人命，如救苍生”。<br>
在送别时，辛德勒痛哭，自己本可以救出更多人。<br>
”这枚胸针...一个人，这辆汽车...三个人“。</p>
<!-- more -->
<p>影片到这儿就结束了，现如今荷兰境内许多犹太人都是辛德勒拯救的犹太人的后裔。</p>
<!-- more -->
<h2 id="战后">战后：</h2>
<p>在此补充一点之后辛德勒的生活：<br>
”到战争结束时，辛德勒的所有积蓄都已经在贿赂和在黑市为工人购买给养中耗尽。几乎一贫如洗的辛德勒曾短暂迁至雷根斯堡，之后再到达慕尼黑，但一直没能在战后的德国发迹。事实上，他已经需要接受犹太人组织的援助来生活。1948年，他向美国犹太人联合分配委员会提出了一份对他的战时开支加以补偿的请求，之后收到了15000美元。他曾估算自己战时的开销超过105.6万美元，包括营地的建设、贿赂，以及包含食品在内的黑市商品支出。辛德勒于1949年移民阿根廷，他在那里试着养鸡和海狸鼠，后者的皮毛有一定的经济价值。可到了1958年就已经破产。然后他离开妻子返回德国，尝试经营包括水泥厂在内的多个产业，但都没有成功。1963年，他再次宣布破产，并于次年因心脏病发而入院治疗了一个月。辛德勒与战争期间认识的许多犹太人保持着联系，来自世界各地“辛德勒犹太人”的资助让他得以继续生活。1974年10月9日，奥斯卡·辛德勒逝世，享年67岁。他的遗体安葬在耶路撒冷的锡安山，是唯一一位得以葬在这里的前纳粹党成员。1963年，以色列授予辛德勒国际义人称号，以表彰他在第二次世界大战期间挽救犹太人免遭大屠杀的功勋，此外，1966年德国政府还授予他联邦十字勋章。“   ------摘自百度百科</p>
<!-- more -->
<h2 id="补充">补充</h2>
<p>影片中有几个很有意思的细节：</p>
<ol>
<li>影片除了片头和片尾唯一的色彩就是一个穿着红衣的小女孩，她的活动过程大概为：玩耍-&gt;躲藏-&gt;被杀害-&gt;火葬  辛德勒每次看到这个小女孩，他的内心就越加的坚定。</li>
<li>中期时有一个犹太人来找辛德勒，想让他的工厂接纳她的父母，辛德勒本没有答应，后来还是接纳了他们。</li>
</ol>
<h1 id="还有好多的细节详情自行走视频网站">还有好多的细节，详情自行走视频网站。</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】题解 AT4741 【[ABC132D] Blue and Red Balls】]]></title>
        <id>https://chuzihang714.github.io/post/oi-ti-jie-at4741-abc132d-blue-and-red-balls/</id>
        <link href="https://chuzihang714.github.io/post/oi-ti-jie-at4741-abc132d-blue-and-red-balls/">
        </link>
        <updated>2021-03-19T12:55:38.000Z</updated>
        <content type="html"><![CDATA[<p>首先，我们需要了解一个事实，这个事实对于解决这道题至关重要，那就是，我们如果要去取篮球，那么就得整个区间都取了。</p>
<p>也就是说，如果要取篮球，就得整块整块的取。形式化地说，就是若你要取篮球 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> ，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j\rightarrow k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 都是篮球 （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j \le i \le k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>），那么就必须取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>→</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j \rightarrow k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>的所有篮球。</p>
<p><strong>证明:</strong> 若取了一个篮球，而多取连续的一个，不会有多花费，那么不取白不取，肯定是取走一块优。</p>
<p>有了这样一个条件，那么&quot;以最少的步数取走篮球&quot; 意思其实是说 &quot;每次取走连续一块篮球&quot;。</p>
<p>所以，只需要看做将红球插入到篮球里就可以了。</p>
<p>易得答案 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mi>n</mi><mi>i</mi></msubsup><mo>×</mo><msubsup><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_n^i\times C_{i-1}^{k - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.071664em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.224434em;vertical-align:-0.335195em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8892389999999999em;"><span style="top:-2.423136em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.335195em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>这怎么会是易得的呢？根本就不易得吧！那么我们就不要易得吧。不易得就要推导，现在我们就来推导一下。</p>
<p>首先，我们有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个篮球， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个红球, 要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 次就是有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个连续的块，由我们前面得到的结论，我们如果要去取篮球，那么就得整个区间都取了就可以轻松得到。所以答案就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mi>i</mi><mi>n</mi></mfrac><mo fence="true">)</mo></mrow><mo>×</mo><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\binom{i}{n} \times \binom{i-1}{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.255674em;vertical-align:-0.35001em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9056639999999999em;"><span style="top:-2.3550000000000004em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.308995em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.905664em;"><span style="top:-2.355em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.144em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span>,是不是特别的有道理。</p>
<p>如果你还是没有明白，那么我们就不要这么直接了，首先，考虑有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个球放在那里，然后插入进去红球，就可以得到上式了。</p>
<p>如果数据大点，可以用费马小定理求个逆元然后再求组合数。</p>
<p>核心代码</p>
<pre><code class="language-cpp">int C(int m, int n) {
    int ans = 1;
    for (int i = 1; i &lt;= m; i++) ans = (ans * (n - m + i) % mod * ksm(i, mod - 2) % mod) % mod;
    return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】题解AT4787 [ABC129C] Typical Stairs]]></title>
        <id>https://chuzihang714.github.io/post/oi-ti-jie-at4787-abc129c-typical-stairs/</id>
        <link href="https://chuzihang714.github.io/post/oi-ti-jie-at4787-abc129c-typical-stairs/">
        </link>
        <updated>2021-03-19T12:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="思路">思路：</h2>
<p>首先看到题目就会想到一道与这题十分相似的题，应该是叫<strong>爬楼梯</strong>。<br>
两题唯一不同的就是本题多出了一项条件：第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2...a_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个台阶是不能走的。</p>
<p>那么这题就和爬楼梯一样，是一个简单 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span></p>
<p>首先我们定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 阶台阶的<strong>方案数</strong>，因为每次只能上一层或两层，所以状态转移方程也很好推：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>f</mi><mrow><mi>i</mi><mo>−</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">f_i=f_{i-1}+ f_{i-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>  又因为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2...a_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 个台阶不能走，所以我们要定义一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">bool</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 数组，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><msub><mi>f</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">ff_{a_i}=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9445399999999999em;vertical-align:-0.2501em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139199999999997em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span> 则不进行操作，且若连续的两阶台阶都不能走的话就可以直接输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 因为无法走到顶。</p>
<p>知道大致思路后这题还有两个需要注意的小细节</p>
<ol>
<li>在进行状态转移时别忘了取模。</li>
<li>若第一阶和第二阶台阶均可走 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">f_2=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 若只有第二阶可走则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f_2=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
（刚做时我也做错了）</li>
</ol>
<h2 id="code">CODE</h2>
<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define int long long
using namespace std;
int i,n,f[1000001],j,m,a,sum;
bool ff[1000001];
const int mod = 1000000007;
signed main()
{
        cin &gt;&gt; n &gt;&gt; m;
        for (i=1; i&lt;=n; i++) {ff[i]=true; f[i]=0;}
        for (i=1; i&lt;=m; i++) {cin &gt;&gt; a; ff[a]=false;}

        if (ff[1]) f[1]=1; if (ff[2]&amp;&amp;ff[1]) f[2]=2; else if (ff[2]) f[2]=1;

        for (i=3; i&lt;=n; i++)
        {
                if (ff[i-1]==false&amp;&amp;ff[i-2]==false) {cout &lt;&lt; 0; return 0;}
                if (ff[i-1]==false&amp;&amp;ff[i]==false) {cout &lt;&lt; 0; return 0;}
                if (ff[i]) f[i]=(f[i-2]+f[i-1]) % mod;
        }
        sum=f[n]% mod;
        cout &lt;&lt; sum &lt;&lt; endl;
}

</code></pre>
<p>再来一份Pascal的伪代码：</p>
<pre><code class="language-pascal">          if ff[1]=true then f[1]:=1;
          if (ff[2]=true) and (ff[1]=true) then f[2]:=2
                           else if (ff[2]=true)  then f[2]:=1;

        for i:=3 to n do
        begin 
        if (ff[i-1]=false) and (ff[i-2]=false) then 
           begin
              write(0);exit;end;
        if (ff[i-1]=false) and (ff[i]=false) then
           begin
              write(0);exit;end;
          if (ff[i]=true) then 
                 f[i]:=f[i-2]+f[i-1] mod 1000000007; 
        end; 
</code></pre>
<p>八格缩进有点难看请见谅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【OI】题解 P6495 [COCI2016-2017#2] Tavan]]></title>
        <id>https://chuzihang714.github.io/post/oi-ti-jie-p6495-coci2016-20172-tavan/</id>
        <link href="https://chuzihang714.github.io/post/oi-ti-jie-p6495-coci2016-20172-tavan/">
        </link>
        <updated>2021-03-19T12:53:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sol">Sol:</h2>
<p>是一道简单的<strong>字符串</strong>题。</p>
<p>题目大意：给你一个由 <code>#</code> 与小写字母组成的字符串，每个 <code>#</code> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 种字母可填，试求所有方案字典序排列后的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 种方案。</p>
<p>因为是按字典序排列，所以我们可以将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的字符串<strong>一一排序</strong>。然后找每个待更新的 <code>#</code> 要更新的字符的位置，最后更新字符串即可。</p>
<p>建议黄。</p>
<h2 id="code">Code:</h2>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define int long long
using namespace std;
int x,m,k,n,kk,kkk;
int a[501],d[501];
char s[501],ss[501][501];

signed main()
{
        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x;
        x--;
        kk=0;
        scanf(&quot;%s&quot;,s+1);
        for(int i=1; i&lt;=n; i++)
                if(s[i]=='#')
                        d[kk++]=i;//d数组表示#的位置。

        for(int i=0; i&lt;m; i++)
        {
                scanf(&quot;%s&quot;,ss[i]);
                sort(ss[i],ss[i]+k);
        }//因为按字典序，所以要排序。

        kk=0; kkk=1;//kkk就是位值。
        while(kkk*k&lt;=x)
                kkk=k*kkk,kk++;

        while(x &amp;&amp; kk&gt;=0)
        {
                a[kk]=x/kkk;//a数组表示在ss[i]中取第几位字符。
                x-=a[kk--]*kkk;
                kkk/=k;
        }

        for(int i=0; i&lt;m; i++)
                s[d[i]]=ss[i][a[m-i-1]];//更新字符串。
                
        puts(s+1);
}

</code></pre>
]]></content>
    </entry>
</feed>